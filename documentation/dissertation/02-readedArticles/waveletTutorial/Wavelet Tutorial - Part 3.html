<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Wavelet Tutorial - Part 3</title>
    <meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- JQuery -->
    <script src="Wavelet%20Tutorial%20-%20Part%203_arquivos/jquery-3.js"></script>

    <!-- BootStrap -->
    <link rel="stylesheet" href="Wavelet%20Tutorial%20-%20Part%203_arquivos/bootstrap.css">
    <script src="Wavelet%20Tutorial%20-%20Part%203_arquivos/bootstrap.js"></script>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="Wavelet%20Tutorial%20-%20Part%203_arquivos/stylesheet.css">

		<!-- Custom JS -->
		<script src="Wavelet%20Tutorial%20-%20Part%203_arquivos/main.js"></script>

    <!-- Allows for inline LaTeX equations! -->
    <script type="text/x-mathjax-config;executed=true">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1px; bottom: 2px; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style>

  <style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style></head>

  <body><div id="MathJax_Message" style="display: none;"></div>

    <div id="header"><script>

var pages = [
  ["Home", "index.html"],
  ["About Me", "aboutme.html"],
  ["Research", "research.html"],
  ["Publications", "publications.html"],
  ["Signal Processing And Pattern Recognition Laboratory", "spprl.html"],
  ["Research Funding", "research-funding.html"],
  ["The Wavelet Tutorial", "WTtutorial.html"],
  ["Rowan ECE", "https://academics.rowan.edu/engineering/programs/electricalcomputer/index.html"]
];

/* -- Do not edit below this line ---------------------------------------------------------------------------------------- */

</script>


<nav class="navbar navbar-inverse navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="http://users.rowan.edu/~polikar/">Robi Polikar</a>
    </div>
    <ul class="nav navbar-nav">
      <li class="dropdown active">
        <a id="page-label" class="dropdown-toggle" data-toggle="dropdown" href="http://users.rowan.edu/~polikar/"><span class="caret"></span></a>
        <ul id="pages" class="dropdown-menu"><li><a href="http://users.rowan.edu/~polikar/index.html">Home</a></li>
<li><a href="http://users.rowan.edu/~polikar/aboutme.html">About Me</a></li>
<li><a href="http://users.rowan.edu/~polikar/research.html">Research</a></li>
<li><a href="http://users.rowan.edu/~polikar/publications.html">Publications</a></li>
<li><a href="http://users.rowan.edu/~polikar/spprl.html">Signal Processing And Pattern Recognition Laboratory</a></li>
<li><a href="http://users.rowan.edu/~polikar/research-funding.html">Research Funding</a></li>
<li><a href="http://users.rowan.edu/~polikar/WTtutorial.html">The Wavelet Tutorial</a></li>
<li><a href="https://academics.rowan.edu/engineering/programs/electricalcomputer/index.html">Rowan ECE</a></li>
</ul>
      </li>
    </ul>
  </div>
</nav>

<style>

body {
  margin-top: 50px; /* Gives a little space under header */
}

</style>

<script>

  // Initialize the HTML as empty
  var pagesHTML = "";

  // Get the current page name
  // Removed for cleaner UI - BW
  /*var pageName = location.href.split('/');
  pageName = pageName[pageName.length - 1];*/

  for(var i = 0; i < pages.length; i++){

    // Iterate through all pages and build the HTML
    pagesHTML += "<li><a href='" + pages[i][1] + "'>" + pages[i][0] + "</a></li>\n"

    // Search for page name and update top bar if found
    // Removed for cleaner UI - BW
    /*if(pages[i][1] == pageName){
      $("#page-label").html(pages[i][0] + "<span class='caret'></span>");
    }*/

  }

  // Put the generated HTML
  document.getElementById("pages").innerHTML = pagesHTML;

  // Make the dropdown show on hover
  $('ul.nav li.dropdown').hover(function() {
    $(this).find('.dropdown-menu').stop(true, true).delay(100).fadeIn(100);
  }, function() {
    $(this).find('.dropdown-menu').stop(true, true).delay(100).fadeOut(100);
  });

</script>
</div>

    <div class="col-sm-2"></div>

    <div class="col-sm-8 page-body">

      <h1 class="page-title">Wavelet Tutorial - Part 3</h1>
      <h1 class="page-subtitle">by Robi Polikar</h1>
      <hr>

      <h1 class="section-title">
        Multiresolution Analysis and the Continuous Wavelet Transform
      </h1>

      <br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/wt7.png" class="img-responsive" style="display:block; margin:auto;">

      <br><br>

      <hr>
      <h1 class="section-title">
        Multiresolution Analysis
      </h1>

      <br><br>

      Although the time and frequency resolution problems are results of
 a physical phenomenon (the Heisenberg uncertainty principle) and exist 
regardless of the transform used, it is possible to analyze any signal 
by using an alternative approach called the <strong>multiresolution analysis (MRA)</strong>.
 MRA, as implied by its name, analyzes the signal at different 
frequencies with different resolutions. Every spectral component is not 
resolved equally as was the case in the STFT.

      <br><br>

      MRA is designed to give good time resolution and poor frequency 
resolution at high frequencies and good frequency resolution and poor 
time resolution at low frequencies. This approach makes sense especially
 when the signal at hand has high frequency components for short 
durations and low frequency components for long durations. Fortunately, 
the signals that are encountered in practical applications are often of 
this type. For example, the following shows a signal of this type. It 
has a relatively low frequency component throughout the entire signal 
and relatively high frequency components for a short duration somewhere 
around the middle.

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_1.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.1
      </div>

      <br><br>

      <hr>
      <h1 class="section-title">
        The Continuous Wavelet Transform
      </h1>

      <br>

      The continuous wavelet transform was developed as an alternative 
approach to the short time Fourier transform to overcome the resolution 
problem. The wavelet analysis is done in a similar way to the STFT 
analysis, in the sense that the signal is multiplied with a function, 
{\it the wavelet}, similar to the window function in the STFT, and the 
transform is computed separately for different segments of the 
time-domain signal. However, there are two main differences between the 
STFT and the CWT:

      <br>

      <ol>
        <li>The Fourier transforms of the windowed signals are not 
taken, and therefore single peak will be seen corresponding to a 
sinusoid, i.e., negative frequencies are not computed.</li>
        <li>The width of the window is changed as the transform is 
computed for every single spectral component, which is probably the most
 significant characteristic of the wavelet transform.</li>
      </ol>

      <br>

      The continuous wavelet transform is defined as follows

      <br><br>

      <!--img src="res/wavelet/part3/wt_eqn1.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">CWT_x^\psi(\tau,s) = \Psi_x^\psi(\tau,s) = \frac{1}{\sqrt{|s|}} \int x(t) \psi^* \left(  \frac{t - \tau}{s} \right) dt</span><script type="math/tex">CWT_x^\psi(\tau,s) = \Psi_x^\psi(\tau,s) = \frac{1}{\sqrt{|s|}} \int x(t) \psi^* \left(  \frac{t - \tau}{s} \right) dt</script> <br><br>
        Equation 3.1
      </div>

      <br><br>

      As seen in the above equation, the transformed signal is a function of two variables, <strong>tau</strong> and <strong>s</strong>, the <strong>translation</strong> and <strong>scale</strong> parameters, respectively. <span class="MathJax_Preview">\psi(t)</span><script type="math/tex">\psi(t)</script> is the transforming function, and it is called the <strong>mother wavelet</strong>. The term mother wavelet gets its name due to two important properties of the wavelet analysis as explained below:

      <br><br>

      The term <strong>wavelet</strong> means a <strong>small wave</strong>. The smallness refers to the condition that this (window) function is of finite length (<strong>compactly supported</strong>). The wave refers to the condition that this function is oscillatory . The term <strong>mother</strong>
 implies that the functions with different region of support that are 
used in the transformation process are derived from one main function, 
or the mother wavelet. In other words, the mother wavelet is a <strong>prototype</strong> for generating the other window functions.

      <br><br>

      The term <strong>translation</strong> is used in the same sense as
 it was used in the STFT; it is related to the location of the window, 
as the window is shifted through the signal. This term, obviously, 
corresponds to time information in the transform domain. However, we do 
not have a frequency parameter, as we had before for the STFT. Instead, 
we have scale parameter which is defined as <span class="MathJax_Preview">\frac{1}{frequency}</span><script type="math/tex">\frac{1}{frequency}</script>. The term frequency is reserved for the STFT. Scale is described in more detail in the next section.

      <br><br>

      <hr>
      <h1 class="section-title">
        The Scale
      </h1>

      <br>

      The parameter <strong>scale</strong> in the wavelet analysis is 
similar to the scale used in maps. As in the case of maps, high scales 
correspond to a non-detailed global view (of the signal), and low scales
 correspond to a detailed view. Similarly, in terms of frequency, low 
frequencies (high scales) correspond to a global information of a signal
 (that usually spans the entire signal), whereas high frequencies (low 
scales) correspond to a detailed information of a hidden pattern in the 
signal (that usually lasts a relatively short time). Cosine signals 
corresponding to various scales are given as examples in the following 
figure .

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_2.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.2
      </div>

      <br><br>

      Fortunately in practical applications, low scales (high 
frequencies) do not last for the entire duration of the signal, unlike 
those shown in the figure, but they usually appear from time to time as 
short bursts, or spikes. High scales (low frequencies) usually last for 
the entire duration of the signal.

      <br><br>

      Scaling, as a mathematical operation, either dilates or compresses
 a signal. Larger scales correspond to dilated (or stretched out) 
signals and small scales correspond to compressed signals. All of the 
signals given in the figure are derived from the same cosine signal, 
i.e., they are dilated or compressed versions of the same function. In 
the above figure, <strong>s = 0.05</strong> is the smallest scale, and <strong>s = 1</strong> is the largest scale.

      <br><br>

      In terms of mathematical functions, if <strong>f(t)</strong> is a given function <strong>f(st)</strong> corresponds to a contracted (compressed) version of <strong>f(t)</strong> if <strong>s &gt; 1</strong> and to an expanded (dilated) version of <strong>f(t)</strong> if <strong>s &lt; 1</strong>.

      <br><br>

      However, in the definition of the wavelet transform, the scaling 
term is used in the denominator, and therefore, the opposite of the 
above statements holds, i.e., scales <strong>s &gt; 1</strong> dilates the signals whereas scales <strong>s &lt; 1</strong> , compresses the signal. This interpretation of scale will be used throughout this text.

      <br><br>

      <hr>
      <h1 class="section-title">
        Computation of the CWT
      </h1>

      <br>

      Interpretation of the above equation will be explained in this section. Let <strong>x(t)</strong>
 is the signal to be analyzed. The mother wavelet is chosen to serve as a
 prototype for all windows in the process. All the windows that are used
 are the dilated (or compressed) and shifted versions of the mother 
wavelet. There are a number of functions that are used for this purpose.
 The Morlet wavelet and the Mexican hat function are two candidates, and
 they are used for the wavelet analysis of the examples which are 
presented later in this chapter.

      <br><br>

      Once the mother wavelet is chosen the computation starts with <strong>s = 1</strong>
 and the continuous wavelet transform is computed for all values of s , 
smaller and larger than ``1''. However, depending on the signal, a 
complete transform is usually not necessary. For all practical purposes,
 the signals are bandlimited, and therefore, computation of the 
transform for a limited interval of scales is usually adequate. In this 
study, some finite interval of values for s were used, as will be 
described later in this chapter.

      <br><br>

      For convenience, the procedure will be started from scale <strong>s = 1</strong>
 and will continue for the increasing values of s , i.e., the analysis 
will start from high frequencies and proceed towards low frequencies. 
This first value of s will correspond to the most compressed wavelet. As
 the value of s is increased, the wavelet will dilate.

      <br><br>

      The wavelet is placed at the beginning of the signal at the point 
which corresponds to time = 0. The wavelet function at scale ``1'' is 
multiplied by the signal and then integrated <strong>over all times</strong>. The result of the integration is then multiplied by the constant number <span class="MathJax_Preview">\frac{1}{\sqrt{s}}</span><script type="math/tex">\frac{1}{\sqrt{s}}</script>.
 This multiplication is for energy normalization purposes so that the 
transformed signal will have the same energy at every scale. The final 
result is the value of the transformation, i.e., the value of the 
continuous wavelet transform <strong>at time zero</strong> and <strong>scale s = 1</strong> . In other words, it is the value that corresponds to the point <strong><span class="MathJax_Preview">\boldsymbol \tau</span><script type="math/tex">\boldsymbol \tau</script> = 0</strong> , <strong>s = 1</strong> in the time-scale plane.

      <br><br>

      The wavelet at scale <strong>s = 1</strong> is then shifted towards the right by <span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script> amount to the location <strong>t = <span class="MathJax_Preview">\boldsymbol \tau</span><script type="math/tex">\boldsymbol \tau</script></strong> , and the above equation is computed to get the transform value at <strong>t = tau</strong>, <strong>s = 1</strong> in the time-frequency plane.

      <br><br>

      This procedure is repeated until the wavelet reaches the end of the signal. <strong>One row of points on the time-scale plane</strong> for the scale <strong>s = 1</strong> is now completed.

      <br><br>

      Then, <strong>s</strong> is increased by a small value. Note that, this is a continuous transform, and therefore, both <span class="MathJax_Preview">\boldsymbol \tau</span><script type="math/tex">\boldsymbol \tau</script> and <strong>s</strong>
 must be incremented continuously . However, if this transform needs to 
be computed by a computer, then both parameters are increased by a <strong>sufficiently small step size</strong>. This corresponds to sampling the time-scale plane.

      <br><br>

      The above procedure is repeated for every value of s. Every 
computation for a given value of s fills the corresponding single row of
 the time-scale plane. When the process is completed for all desired 
values of s, the CWT of the signal has been calculated.

      <br><br>

      The figures below illustrate the entire process step by step.

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_3.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.3
      </div>

      <br><br>

      In Figure 3.3, the signal and the wavelet function are shown for four different values of <span class="MathJax_Preview">\boldsymbol \tau</span><script type="math/tex">\boldsymbol \tau</script>. The signal is a truncated version of the signal shown in Figure 3.1. The scale value is <strong>1</strong>
 , corresponding to the lowest scale, or highest frequency. Note how 
compact it is (the blue window). It should be as narrow as the highest 
frequency component that exists in the signal. Four distinct locations 
of the wavelet function are shown in the figure at <strong><span class="MathJax_Preview">\boldsymbol {t_o}</span><script type="math/tex">\boldsymbol {t_o}</script> = 2 , <span class="MathJax_Preview">\boldsymbol {t_o}</span><script type="math/tex">\boldsymbol {t_o}</script> = 40, <span class="MathJax_Preview">\boldsymbol {t_o}</span><script type="math/tex">\boldsymbol {t_o}</script> = 90, and <span class="MathJax_Preview">\boldsymbol {t_o}</span><script type="math/tex">\boldsymbol {t_o}</script> = 140</strong>
 . At every location, it is multiplied by the signal. Obviously, the 
product is nonzero only where the signal falls in the region of support 
of the wavelet, and it is zero elsewhere. By shifting the wavelet in 
time, the signal is localized in time, and by changing the value of s , 
the signal is localized in scale (frequency).

      <br><br>

      If the signal has a spectral component that corresponds to the 
current value of s (which is 1 in this case), the product of the wavelet
 with the signal <strong>at the location where this spectral component exists</strong>
 gives a relatively large value. If the spectral component that 
corresponds to the current value of s is not present in the signal, the 
product value will be relatively small, or zero. The signal in Figure 
3.3 has spectral components comparable to the window's width at <strong>s = 1</strong> around <strong>t = 100 ms</strong>.

      <br><br>

      The continuous wavelet transform of the signal in Figure 3.3 will 
yield large values for low scales around time 100 ms, and small values 
elsewhere. For high scales, on the other hand, the continuous wavelet 
transform will give large values for almost the entire duration of the 
signal, since low frequencies exist at all times.

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_4.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.4
      </div>

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_5.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.5
      </div>

      <br><br>

      Figures 3.4 and 3.5 illustrate the same process for the scales s =
 5 and s = 20, respectively. Note how the window width changes with 
increasing scale (decreasing frequency). As the window width increases, 
the transform starts picking up the lower frequency components.

      <br><br>

      As a result, for every scale and for every time (interval), one 
point of the time-scale plane is computed. The computations at one scale
 construct the rows of the time-scale plane, and the computations at 
different scales construct the columns of the time-scale plane.

      <br><br>

      Now, let's take a look at an example, and see how the wavelet transform really looks like. Consider the <strong>non-stationary</strong>
 signal in Figure 3.6. This is similar to the example given for the 
STFT, except at different frequencies. As stated on the figure, the 
signal is composed of four frequency components at 30 Hz, 20 Hz, 10 Hz 
and 5 Hz.

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_6.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.6
      </div>

      <br><br>

      Figure 3.7 is the continuous wavelet transform (CWT) of this 
signal. Note that the axes are translation and scale, not time and 
frequency. However, translation is strictly related to time, since it 
indicates where the mother wavelet is located. The translation of the 
mother wavelet can be thought of as the time elapsed since <strong>t = 0</strong>
 . The scale, however, has a whole different story. Remember that the 
scale parameter s in equation 3.1 is actually inverse of frequency. In 
other words, whatever we said about the properties of the wavelet 
transform regarding the frequency resolution, inverse of it will appear 
on the figures showing the WT of the time-domain signal.

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_7.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.7
      </div>

      <br><br>

      Note that in Figure 3.7 that smaller scales correspond to higher 
frequencies, i.e., frequency decreases as scale increases, therefore, 
that portion of the graph with scales around zero, actually correspond 
to highest frequencies in the analysis, and that with high scales 
correspond to lowest frequencies. Remember that the signal had 30 Hz 
(highest frequency) components first, and this appears at the lowest 
scale at a translations of 0 to 30. Then comes the 20 Hz component, 
second highest frequency, and so on. The 5 Hz component appears at the 
end of the translation axis (as expected), and at higher scales (lower 
frequencies) again as expected.

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_8.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.8
      </div>

      <br><br>

      Now, recall these resolution properties: Unlike the STFT which has
 a constant resolution at all times and frequencies, the WT has a good 
time and poor frequency resolution at high frequencies, and good 
frequency and poor time resolution at low frequencies. Figure 3.8 shows 
the same WT in Figure 3.7 from another angle to better illustrate the 
resolution properties: In Figure 3.8, lower scales (higher frequencies) 
have <strong>better scale resolution</strong> (narrower in scale, which means that it is less ambiguous what the exact value of the scale) which correspond to <strong>poorer frequency</strong>
 resolution . Similarly, higher scales have scale frequency resolution 
(wider support in scale, which means it is more ambitious what the exact
 value of the scale is) , which correspond to better frequency 
resolution of lower frequencies.

      <br><br>

      The axes in Figure 3.7 and 3.8 are normalized and should be 
evaluated accordingly. Roughly speaking the 100 points in the 
translation axis correspond to 1000 ms, and the 150 points on the scale 
axis correspond to a frequency band of 40 Hz (the numbers on the 
translation and scale axis <strong>do not correspond</strong> to seconds and Hz, respectively , they are just the number of samples in the computation).

      <br><br>

      <hr>
      <h1 class="section-title">
        Time and Frequency Resolutions
      </h1>

      <br>

      In this section we will take a closer look at the resolution 
properties of the wavelet transform. Remember that the resolution 
problem was the main reason why we switched from STFT to WT.

      <br><br>

      The illustration in Figure 3.9 is commonly used to explain how 
time and frequency resolutions should be interpreted. Every box in 
Figure 3.9 corresponds to a value of the wavelet transform in the 
time-frequency plane. Note that boxes have a certain <strong>non-zero</strong>
 area, which implies that the value of a particular point in the 
time-frequency plane cannot be known. All the points in the 
time-frequency plane that falls into a box is represented by one value 
of the WT.

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_9.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.9
      </div>

      <br><br>

      Let's take a closer look at Figure 3.9: First thing to notice is 
that although the widths and heights of the boxes change, the area is 
constant. That is each box represents an equal portion of the 
time-frequency plane, but giving different proportions to time and 
frequency. Note that at low frequencies, the height of the boxes are 
shorter (which corresponds to better frequency resolutions, since there 
is less ambiguity regarding the value of the exact frequency), but their
 widths are longer (which correspond to poor time resolution, since 
there is more ambiguity regarding the value of the exact time). At 
higher frequencies the width of the boxes decreases, i.e., the time 
resolution gets better, and the heights of the boxes increase, i.e., the
 frequency resolution gets poorer.

      <br><br>

      Before concluding this section, it is worthwhile to mention how 
the partition looks like in the case of STFT. Recall that in STFT the 
time and frequency resolutions are determined by the width of the 
analysis window, which is selected once for the entire analysis, i.e., 
both time and frequency resolutions are constant. Therefore the 
time-frequency plane consists of <strong>squares</strong> in the STFT case.

      <br><br>

      Regardless of the dimensions of the boxes, the areas of all boxes, both in STFT and WT, are the same and determined by <strong>Heisenberg's inequality</strong>
 . As a summary, the area of a box is fixed for each window function 
(STFT) or mother wavelet (CWT), whereas different windows or mother 
wavelets can result in different areas. However, <strong>all areas are lower bounded by</strong> <span class="MathJax_Preview">\boldsymbol {\frac{1}{4} \pi}</span><script type="math/tex">\boldsymbol {\frac{1}{4} \pi}</script>.
 That is, we cannot reduce the areas of the boxes as much as we want due
 to the Heisenberg's uncertainty principle. On the other hand, for a 
given mother wavelet the dimensions of the boxes can be changed, while 
keeping the area the same. This is exactly what wavelet transform does.

      <br><br>

      <hr>
      <h1 class="section-title">
        The Wavelet Theory: A Mathematical Approach
      </h1>

      <br>

      This section describes the main idea of wavelet analysis theory, 
which can also be considered to be the underlying concept of most of the
 signal analysis techniques. The FT defined by Fourier use <strong>basis functions</strong> to analyze and reconstruct a function. <strong>Every vector in a vector space can be written as a linear combination of the basis vectors in that vector space</strong>
 , i.e., by multiplying the vectors by some constant numbers, and then 
by taking the summation of the products. The analysis of the signal 
involves the estimation of these constant numbers (transform 
coefficients, or Fourier coefficients, wavelet coefficients, etc). The 
synthesis, or the reconstruction, corresponds to computing the linear 
combination equation.

      <br><br>

      All the definitions and theorems related to this subject can be found in Keiser's book, <strong>A Friendly Guide to Wavelets</strong>
 but an introductory level knowledge of how basis functions work is 
necessary to understand the underlying principles of the wavelet theory.
 Therefore, this information will be presented in this section.

      <br><br>

      <hr>
      <h1 class="section-title">
        Basis Vectors
      </h1>

      <br>

      Note: Most of the equations include letters of the Greek alphabet.
 These letters are written out explicitly in the text with their names, 
such as <strong>tau, psi, phi</strong> etc. For capital letters, the first letter of the name has been capitalized, such as, <strong>Tau, Psi, Phi</strong>
 etc. Also, subscripts are shown by the underscore character _ , and 
superscripts are shown by the ^ character. Also note that all letters or
 letter names written in bold type face represent vectors, Some 
important points are also written in bold face, but the meaning should 
be clear from the context.

      <br><br>

      A <strong>basis</strong> of a vector space <strong>V</strong> is a set of linearly independent vectors, such that any vector <strong>v</strong> in <strong>V</strong>
 can be written as a linear combination of these basis vectors. There 
may be more than one basis for a vector space. However, all of them have
 the same number of vectors, and this number is known as the <strong>dimension</strong> of the vector space. For example in two-dimensional space, the basis will have two vectors.

      <br><br>

      <!--img src="res/wavelet/part3/equation3_2.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">v = \sum\limits_{k} \nu^k b_k</span><script type="math/tex">v = \sum\limits_{k} \nu^k b_k</script> <br><br>
        Equation 3.2
      </div>

      <br><br>

      Equation 3.2 shows how any vector <strong>v</strong> can be written as a linear combination of the basis vectors <span class="MathJax_Preview">\boldsymbol {b_k}</span><script type="math/tex">\boldsymbol {b_k}</script> and the corresponding coefficients <span class="MathJax_Preview">\boldsymbol {\nu^k}</span><script type="math/tex">\boldsymbol {\nu^k}</script>.

      <br><br>

      This concept, given in terms of vectors, can easily be generalized to functions, by replacing the basis vectors <span class="MathJax_Preview">\boldsymbol {b_k}</span><script type="math/tex">\boldsymbol {b_k}</script> with basis functions <span class="MathJax_Preview">\boldsymbol {\phi_k(t)}</span><script type="math/tex">\boldsymbol {\phi_k(t)}</script>, and the vector <strong>v</strong> with a function <strong>f(t)</strong>. Equation 3.2 then becomes

      <br><br>

      <!--img src="res/wavelet/part3/equation3_2a.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">f(t) = \sum\limits_{k} \mu_k \phi_k (t)</span><script type="math/tex">f(t) = \sum\limits_{k} \mu_k \phi_k (t)</script> <br><br>
        Equation <span class="MathJax_Preview">3.2_a</span><script type="math/tex">3.2_a</script>
      </div>

      <br><br>

      The complex exponential (sines and cosines) functions are the 
basis functions for the FT. Furthermore, they are orthogonal functions, 
which provide some desirable properties for reconstruction.

      <br><br>

      Let f(t) and g(t) be two functions in <span class="MathJax_Preview">L^2 [a,b]</span><script type="math/tex">L^2 [a,b]</script>. (<span class="MathJax_Preview">L^2 [a,b]</span><script type="math/tex">L^2 [a,b]</script> denotes the set of square integrable functions in the interval <span class="MathJax_Preview">[a,b]</span><script type="math/tex">[a,b]</script>). The inner product of two functions is defined by Equation 3.3:

      <br><br>

      <!--img src="res/wavelet/part3/equation3_3.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">&lt; f(t), g(t) &gt; = \int_a^b f(t) \cdot g^*(t) dt</span><script type="math/tex">< f(t), g(t) > = \int_a^b f(t) \cdot g^*(t) dt</script> <br><br>
        Equation 3.3
      </div>

      <br><br>

      According to the above definition of the inner product, the CWT 
can be thought of as the inner product of the test signal with the basis
 functions <span class="MathJax_Preview">\psi_(\tau ,s)(t)</span><script type="math/tex">\psi_(\tau ,s)(t)</script>:

      <br><br>

      <!--img src="res/wavelet/part3/equation3_4.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">CWT_x^\psi(\tau, s) = \Psi_x^\psi(\tau, s) = \int x(t) \cdot \psi^*_{\tau, s}(t) dt</span><script type="math/tex">CWT_x^\psi(\tau, s) = \Psi_x^\psi(\tau, s) = \int x(t) \cdot \psi^*_{\tau, s}(t) dt</script> <br><br>
        Equation 3.4
      </div>

      <br><br>

      where,

      <br><br>

      <!--img src="res/wavelet/part3/equation3_5.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\psi_{\tau, s} = \frac{1}{\sqrt{s}} \psi \left( \frac{t - \tau}{s} \right)</span><script type="math/tex">\psi_{\tau, s} = \frac{1}{\sqrt{s}} \psi \left( \frac{t - \tau}{s} \right)</script> <br><br>
        Equation 3.5
      </div>

      <br><br>

      This definition of the CWT shows that the wavelet analysis is a 
measure of similarity between the basis functions (wavelets) and the 
signal itself. Here the similarity is in the sense of similar frequency 
content. The calculated CWT coefficients refer to the closeness of the 
signal to the wavelet <strong>at the current scale</strong> .

      <br><br>

      This further clarifies the previous discussion on the correlation 
of the signal with the wavelet at a certain scale. If the signal has a 
major component of the frequency corresponding to the current scale, 
then the wavelet (the basis function) at the current scale will be <strong>similar</strong> or <strong>close</strong>
 to the signal at the particular location where this frequency component
 occurs. Therefore, the CWT coefficient computed at this point in the 
time-scale plane will be a relatively large number.

      <br><br>

      <hr>
      <h1 class="section-title">
        Inner Products, Orthogonality, and Orthonormality
      </h1>

      <br>

      Two vectors <strong>v</strong> , <strong>w</strong> are said to be <strong>orthogonal</strong> if their inner product equals zero

      <br><br>

      <!--img src="res/wavelet/part3/equation3_6.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">&lt; v, w &gt; = \sum\limits_{n} v_n w^*_n = 0</span><script type="math/tex">< v, w > = \sum\limits_{n} v_n w^*_n = 0</script> <br><br>
        Equation 3.6
      </div>

      <br><br>

      Similarly, two functions <span class="MathJax_Preview">f</span><script type="math/tex">f</script> and <span class="MathJax_Preview">g</span><script type="math/tex">g</script> are said to be orthogonal to each other if their inner product is zero:

      <br><br>

      <!--img src="res/wavelet/part3/equation3_7.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">&lt; f(t), g(t) &gt; = \int_a^b f(t) \cdot g^*(t) \cdot dt = 0</span><script type="math/tex">< f(t), g(t) > = \int_a^b f(t) \cdot g^*(t) \cdot dt = 0</script> <br><br>
        Equation 3.7
      </div>

      <br><br>

      A set of vectors {<span class="MathJax_Preview">\boldsymbol{v_1, v_2, ....,v_n}</span><script type="math/tex">\boldsymbol{v_1, v_2, ....,v_n}</script>} is said to be <strong>orthonormal</strong> , if they are pairwise orthogonal to each other, and all have length "1". This can be expressed as:

      <br><br>

      <!--img src="res/wavelet/part3/equation3_8.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">&lt; v_m, v_n &gt; = \delta_{mn}</span><script type="math/tex">< v_m, v_n > = \delta_{mn}</script> <br><br>
        Equation 3.8
      </div>

      <br><br>

      Similarly, a set of functions {<span class="MathJax_Preview">phi_k(t)</span><script type="math/tex">phi_k(t)</script>}, <span class="MathJax_Preview">k=1,2,3,...,</span><script type="math/tex">k=1,2,3,...,</script> is said to be orthonormal if

      <br><br>

      <!--img src="res/wavelet/part3/equation3_9.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\int_a^b \phi_k(t) \cdot \phi^*_l(t) \cdot dt = 0</span><script type="math/tex">\int_a^b \phi_k(t) \cdot \phi^*_l(t) \cdot dt = 0</script> <span class="MathJax_Preview">k \neq l</span><script type="math/tex">k \neq l</script> (orthogonality cond.) <br><br>
        Equation 3.9
      </div>

      <br><br>

      and

      <br><br>

      <!--img src="res/wavelet/part3/equation3_10.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\int_a^b \{ | \phi_k(t) | \}^2 dx = 1</span><script type="math/tex">\int_a^b \{ | \phi_k(t) | \}^2 dx = 1</script> <br><br>
        Equation 3.10
      </div>

      <br><br>

      or equivalently

      <br><br>

      <!--img src="res/wavelet/part3/equation3_11.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\int_a^b \phi_k(t) \cdot \phi_l^*(t) \cdot dt = \delta_{kl}</span><script type="math/tex">\int_a^b \phi_k(t) \cdot \phi_l^*(t) \cdot dt = \delta_{kl}</script> <br><br>
        Equation 3.11
      </div>

      <br><br>

      where, <span class="MathJax_Preview">\delta_{kl}</span><script type="math/tex">\delta_{kl}</script> is the <strong>Kronecker delta</strong> function, defined as:

      <br><br>

      <!--img src="res/wavelet/part3/equation3_12.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\delta_{kl} =
        \left\{
          \begin{array}{ll}
          1, &amp; k = l \\
          0, &amp; k \neq l\\
          \end{array}
        \right.</span><script type="math/tex">\delta_{kl} =
        \left\{
          \begin{array}{ll}
          1, & k = l \\
          0, & k \neq l\\
          \end{array}
        \right.</script>
        <br><br>
        Equation 3.12
      </div>

      <br><br>

      As stated above, there may be more than one set of basis functions
 (or vectors). Among them, the orthonormal basis functions (or vectors) 
are of particular importance because of the nice properties they provide
 in finding these analysis coefficients. The orthonormal bases allow 
computation of these coefficients in a very simple and straightforward 
way using the orthonormality property.

      <br><br>

      For orthonormal bases, the coefficients, <span class="MathJax_Preview">\mu_k</span><script type="math/tex">\mu_k</script>, can be calculated as

      <br><br>

      <!--img src="res/wavelet/part3/equation3_13.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\mu_k = &lt; f, \phi_k &gt; = \int f(t) \cdot \phi_k^*(t) \cdot dt</span><script type="math/tex">\mu_k = < f, \phi_k > = \int f(t) \cdot \phi_k^*(t) \cdot dt</script> <br><br>
        Equation 3.13
      </div>

      <br><br>

      and the function f(t) can then be reconstructed by Equation <span class="MathJax_Preview">3.2_a</span><script type="math/tex">3.2_a</script> by substituting the <span class="MathJax_Preview">\mu_k</span><script type="math/tex">\mu_k</script> coefficients. This yields

      <br><br>

      <!--img src="res/wavelet/part3/equation3_14.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">f(t) = \sum\limits_{k} \mu_k \phi_k(t) = \sum\nolimits_{k} &lt; f, \phi_k &gt; \phi_k(t)</span><script type="math/tex">f(t) = \sum\limits_{k} \mu_k \phi_k(t) = \sum\nolimits_{k} < f, \phi_k > \phi_k(t)</script> <br><br>
        Equation 3.14
      </div>

      <br><br>

      Orthonormal bases may not be available for every type of application where a generalized version, <strong>biorthogonal</strong>
 bases can be used. The term "biorthogonal" refers to two different 
bases which are orthogonal to each other, but each do not form an 
orthogonal set.

      <br><br>

      In some applications, however, biorthogonal bases also may not be 
available in which case frames can be used. Frames constitute an 
important part of wavelet theory, and interested readers are referred to
 Kaiser's book mentioned earlier.

      <br><br>

      Following the same order as in chapter 2 for the STFT, some 
examples of continuous wavelet transform are presented next. The figures
 given in the examples were generated by a program written to compute 
the CWT.

      <br><br>

      Before we close this section, I would like to include two mother 
wavelets commonly used in wavelet analysis. The Mexican Hat wavelet is 
defined as the second derivative of the Gaussian function:

      <br><br>

      <!--img src="res/wavelet/part3/equation3_15.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">w(t) = \frac{1}{\sqrt{2\pi} \cdot \sigma} e^{\frac{-t^2}{2 \sigma^2}}</span><script type="math/tex">w(t) = \frac{1}{\sqrt{2\pi} \cdot \sigma} e^{\frac{-t^2}{2 \sigma^2}}</script> <br><br>
        Equation 3.15
      </div>

      <br><br>

      which is

      <br><br>

      <!--img src="res/wavelet/part3/equation3_16.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\psi(t) = \frac{1}{\sqrt{2 \pi} 
\cdot \sigma^3} \left( e^{\frac{-t^2}{2 \sigma^2}} \cdot \left( 
\frac{t^2}{\sigma^2} - 1 \right) \right)</span><script type="math/tex">\psi(t) = \frac{1}{\sqrt{2 \pi} \cdot \sigma^3} \left( e^{\frac{-t^2}{2 \sigma^2}} \cdot \left( \frac{t^2}{\sigma^2} - 1 \right) \right)</script> <br><br>
        Equation 3.16
      </div>

      <br><br>

      The Morlet wavelet is defined as

      <br><br>

      <!--img src="res/wavelet/part3/equation3_16a.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">w(t) = e^{i a t} \cdot e^{-\frac{t^2}{2\sigma}}</span><script type="math/tex">w(t) = e^{i a t} \cdot e^{-\frac{t^2}{2\sigma}}</script> <br><br>
        Equation <span class="MathJax_Preview">3.16_a</span><script type="math/tex">3.16_a</script>
      </div>

      <br><br>

      where <strong>a</strong> is a modulation parameter, and <strong>sigma</strong> is the scaling parameter that affects the width of the window.

      <br><br>

      <hr>
      <h1 class="section-title">
        Examples
      </h1>

      <br>

      All of the examples that are given below correspond to real-life 
non-stationary signals. These signals are drawn from a database signals 
that includes <strong>event related potentials</strong> of normal 
people, and patients with Alzheimer's disease. Since these are not test 
signals like simple sinusoids, it is not as easy to interpret them. They
 are shown here only to give an idea of how real-life CWTs look like.

      <br><br>

      The following signal shown in Figure 3.11 belongs to a normal person.

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_11.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.11
      </div>

      <br><br>

      and the following is its CWT. The numbers on the axes are of no 
importance to us. those numbers simply show that the CWT was computed at
 350 translation and 60 scale locations on the translation-scale plane. 
The important point to note here is the fact that the computation is not
 a true <strong>continuous</strong> WT, as it is apparent from the 
computation at finite number of locations. This is only a discretized 
version of the CWT, which is explained later on this page. Note, 
however, that this is NOT discrete wavelet transform (DWT) which is the 
topic of Part IV of this tutorial.

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_12.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.12
      </div>

      <br><br>

      and the Figure 3.13 plots the same transform from a different angle for better visualization.

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_13.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.13
      </div>

      <br><br>

      Figure 3.14 plots an event related potential of a patient diagnosed with Alzheimer's disease

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_14.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.14
      </div>

      <br><br>

      and Figure 3.15 illustrates its CWT:

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_15.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.15
      </div>

      <br><br>

      and here is another view from a different angle

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_16.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.16
      </div>

      <br><br>

      <hr>
      <h1 class="section-title">
        The Wavelet Synthesis
      </h1>

      <br>

      The continuous wavelet transform is a reversible transform, 
provided that Equation 3.18 is satisfied. Fortunately, this is a very 
non-restrictive requirement. The continuous wavelet transform is 
reversible if Equation 3.18 is satisfied, even though the basis 
functions are in general may not be orthonormal. The reconstruction is 
possible by using the following reconstruction formula:

      <br><br>

      <!--img src="res/wavelet/part3/equation3_17.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <!-- I took some liberties formatting this one - BW -->
        <span class="MathJax_Preview">x(t) = \frac{1}{C_\psi^2} \int_s 
\int_\tau \left[ \Psi^\psi_x(\tau, s) \frac{1}{s^2} \psi \left( \frac{t -
 \tau}{s} \right) \right] d\tau \cdot ds</span><script type="math/tex">x(t) = \frac{1}{C_\psi^2} \int_s \int_\tau \left[ \Psi^\psi_x(\tau, s) \frac{1}{s^2} \psi \left( \frac{t - \tau}{s} \right) \right] d\tau \cdot ds</script> <br><br>
        Equation 3.17
      </div>

      <br><br>

      where <span class="MathJax_Preview">C_\psi</span><script type="math/tex">C_\psi</script> is a constant that depends on the wavelet used. The success of the reconstruction depends on this constant called, <strong>the admissibility constant</strong> , to satisfy the following <strong>admissibility condition</strong> :

      <br><br>

      <!--img src="res/wavelet/part3/equation3_18.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">C_\psi = \left\{ 2 \pi \int_{-\infty}^{\infty} \frac{|\hat{\psi}(\xi)|^2}{|\zeta|} d\xi \right\} ^{\frac{1}{2}} &lt; \infty</span><script type="math/tex">C_\psi = \left\{ 2 \pi \int_{-\infty}^{\infty} \frac{|\hat{\psi}(\xi)|^2}{|\zeta|} d\xi \right\} ^{\frac{1}{2}} < \infty</script> <br><br>
        Equation 3.18
      </div>

      <br><br>

      where <!--psi^hat(xi)--><span class="MathJax_Preview">\hat{\psi}(\xi)</span><script type="math/tex">\hat{\psi}(\xi)</script> is the FT of <span class="MathJax_Preview">\psi(t)</span><script type="math/tex">\psi(t)</script>. Equation 3.18 implies that <!--psi^hat(0) = 0--><span class="MathJax_Preview">\hat{\psi}(0) = 0</span><script type="math/tex">\hat{\psi}(0) = 0</script>, which is

      <br><br>

      <!--img src="res/wavelet/part3/equation3_19.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\int \psi(t) \cdot dt = 0</span><script type="math/tex">\int \psi(t) \cdot dt = 0</script> <br><br>
        Equation 3.19
      </div>

      <br><br>

      As stated above, Equation 3.19 is not a very restrictive 
requirement since many wavelet functions can be found whose integral is 
zero. For Equation 3.19 to be satisfied, the wavelet must be 
oscillatory.

      <br><br>

      <hr>
      <h1 class="section-title">
        Discretization of the Continuous Wavelet Transform: The Wavelet Series
      </h1>

      <br>

      In today's world, computers are used to do most computations 
(well,...ok... almost all computations). It is apparent that neither the
 FT, nor the STFT, nor the CWT can be practically computed by using 
analytical equations, integrals, etc. It is therefore necessary to 
discretize the transforms. As in the FT and STFT, the most intuitive way
 of doing this is simply sampling the time-frequency (scale) plane. 
Again intuitively, sampling the plane with a uniform sampling rate 
sounds like the most natural choice. However, in the case of WT, the 
scale change can be used to reduce the sampling rate.

      <br><br>

      At higher scales (lower frequencies), the sampling rate can be 
decreased, according to Nyquist's rule. In other words, if the 
time-scale plane needs to be sampled with a sampling rate of <span class="MathJax_Preview">\boldsymbol{N_1}</span><script type="math/tex">\boldsymbol{N_1}</script> at scale <span class="MathJax_Preview">\boldsymbol{s_1}</span><script type="math/tex">\boldsymbol{s_1}</script>, the same plane can be sampled with a sampling rate of <span class="MathJax_Preview">\boldsymbol{N_2}</span><script type="math/tex">\boldsymbol{N_2}</script>, at scale <span class="MathJax_Preview">\boldsymbol{s_2}</span><script type="math/tex">\boldsymbol{s_2}</script>, where, <span class="MathJax_Preview">\boldsymbol{s_1 &lt; s_2}</span><script type="math/tex">\boldsymbol{s_1 < s_2}</script> (corresponding to frequencies <span class="MathJax_Preview">\boldsymbol{f_1 &gt; f_2}</span><script type="math/tex">\boldsymbol{f_1 > f_2}</script> ) and <span class="MathJax_Preview">\boldsymbol{N_2 &lt; N_1}</span><script type="math/tex">\boldsymbol{N_2 < N_1}</script>. The actual relationship between <span class="MathJax_Preview">\boldsymbol{N_1}</span><script type="math/tex">\boldsymbol{N_1}</script> and <span class="MathJax_Preview">\boldsymbol{N_2}</span><script type="math/tex">\boldsymbol{N_2}</script> is

      <br><br>

      <!--img src="res/wavelet/part3/equation3_20.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">N_2 = \frac{s_1}{s_2} N_1</span><script type="math/tex">N_2 = \frac{s_1}{s_2} N_1</script> <br><br>
        Equation 3.20
      </div>

      <br><br>

      or

      <br><br>

      <!--img src="res/wavelet/part3/equation3_21.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">N_2 = \frac{f_2}{f_1} N_1</span><script type="math/tex">N_2 = \frac{f_2}{f_1} N_1</script> <br><br>
        Equation 3.21
      </div>

      <br><br>

      In other words, at lower frequencies the sampling rate can be 
decreased which will save a considerable amount of computation time.

      <br><br>

      It should be noted at this time, however, that the discretization 
can be done in any way without any restriction as far as the analysis of
 the signal is concerned. If synthesis is not required, even the Nyquist
 criteria does not need to be satisfied. The restrictions on the 
discretization and the sampling rate become important if, and only if, 
the signal reconstruction is desired. Nyquist's sampling rate is the 
minimum sampling rate that allows the original <strong>continuous time</strong> signal to be reconstructed from its <strong>discrete</strong> samples. The basis vectors that are mentioned earlier are of particular importance for this reason.

      <br><br>

      As mentioned earlier, the wavelet <span class="MathJax_Preview">\boldsymbol{\psi(\tau,s)}</span><script type="math/tex">\boldsymbol{\psi(\tau,s)}</script>
 satisfying Equation 3.18, allows reconstruction of the signal by 
Equation 3.17. However, this is true for the continuous transform. The 
question is: can we still reconstruct the signal if we discretize the 
time and scale parameters? The answer is "yes", under certain conditions
 (as they always say in commercials: certain restrictions apply !!!).

      <br><br>

      The scale parameter s is discretized first on a logarithmic grid. The time parameter is then discretized <strong>with respect to the scale parameter</strong> , i.e., a different sampling rate is used for every scale. In other words, the sampling is done on the <strong>dyadic</strong> sampling grid shown in Figure 3.17 :

      <br><br>

      <img src="Wavelet%20Tutorial%20-%20Part%203_arquivos/figure3_17.png" class="img-responsive" style="display:block; margin:auto;">
      <div class="text-center">
        Figure 3.17
      </div>

      <br><br>

      Think of the area covered by the axes as the entire time-scale 
plane. The CWT assigns a value to the continuum of points on this plane.
 Therefore, there are an infinite number of CWT coefficients. First 
consider the discretization of the scale axis. Among that infinite 
number of points, only a finite number are taken, using a logarithmic 
rule. The base of the logarithm depends on the user. The most common 
value is 2 because of its convenience. If 2 is chosen, only the scales 
2, 4, 8, 16, 32, 64,...etc. are computed. If the value was 3, the scales
 3, 9, 27, 81, 243,...etc. would have been computed. The time axis is 
then discretized according to the discretization of the scale axis. 
Since the discrete scale changes by factors of 2 , the sampling rate is 
reduced for the time axis by a factor of <strong>2</strong> at every scale.

      <br><br>

      Note that at the lowest scale (s = 2), only 32 points of the time 
axis are sampled (for the particular case given in Figure 3.17). At the 
next scale value, s = 4, the sampling rate of time axis is reduced by a 
factor of 2 since the scale is increased by a factor of 2, and 
therefore, only 16 samples are taken. At the next step, s = 8 and 8 
samples are taken in time, and so on.

      <br><br>

      Although it is called the time-scale plane, it is more accurate to call it the <strong>translation-scale</strong>
 plane, because "time" in the transform domain actually corresponds to 
the shifting of the wavelet in time. For the wavelet series, the actual 
time is still continuous.

      <br><br>

      Similar to the relationship between continuous Fourier transform, 
Fourier series and the discrete Fourier transform, there is a continuous
 wavelet transform, a semi-discrete wavelet transform (also known as 
wavelet series) and a discrete wavelet transform.

      <br><br>

      Expressing the above discretization procedure in mathematical terms, the scale discretization is <span class="MathJax_Preview">\boldsymbol{s = s_0^j}</span><script type="math/tex">\boldsymbol{s = s_0^j}</script>, and translation discretization is <span class="MathJax_Preview">\boldsymbol{\tau = k \cdot s_0^j \cdot \tau_0}</span><script type="math/tex">\boldsymbol{\tau = k \cdot s_0^j \cdot \tau_0}</script> where <span class="MathJax_Preview">\boldsymbol{s_0&gt;1}</span><script type="math/tex">\boldsymbol{s_0>1}</script> and <span class="MathJax_Preview">\boldsymbol{tau_0&gt;0}</span><script type="math/tex">\boldsymbol{tau_0>0}</script>. Note, how the translation discretization is dependent on scale discretization with <span class="MathJax_Preview">\boldsymbol{s_0}</span><script type="math/tex">\boldsymbol{s_0}</script>.

      <br><br>

      The continuous wavelet function

      <br><br>

      <!--img src="res/wavelet/part3/equation3_22.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\psi_{\tau, s} = \frac{1}{\sqrt{s}} \psi \left( \frac{t - \tau}{s} \right)</span><script type="math/tex">\psi_{\tau, s} = \frac{1}{\sqrt{s}} \psi \left( \frac{t - \tau}{s} \right)</script> <br><br>
        Equation 3.22
      </div>

      <br><br>

      <!--img src="res/wavelet/part3/equation3_23.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\psi_{j, k}(t) = s_0^{\frac{-j}{2}} \psi \left( s_0^{-j} - k \tau_0 \right)</span><script type="math/tex">\psi_{j, k}(t) = s_0^{\frac{-j}{2}} \psi \left( s_0^{-j} - k \tau_0 \right)</script> <br><br>
        Equation 3.23
      </div>

      <br><br>

      by inserting <span class="MathJax_Preview">\boldsymbol{s = s_0^{\, j}}</span><script type="math/tex">\boldsymbol{s = s_0^{\, j}}</script>, and <span class="MathJax_Preview">\boldsymbol{\tau = k \cdot s_0^{\, j} \cdot \tau_0}</span><script type="math/tex">\boldsymbol{\tau = k \cdot s_0^{\, j} \cdot \tau_0}</script>.

      <br><br>

      If <span class="MathJax_Preview">\boldsymbol{ \left\{ \psi_{(j, \, k)} \right\} }</span><script type="math/tex">\boldsymbol{ \left\{ \psi_{(j, \, k)} \right\} }</script> constitutes an orthonormal basis, the wavelet series transform becomes

      <br><br>

      <!--img src="res/wavelet/part3/equation3_24.png" class="img-responsive" style="display:block; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\Psi^{\psi_{\, j,k}}_x = \int x(t) \, \psi^*_{j, \, k}(t) \, dt</span><script type="math/tex">\Psi^{\psi_{\, j,k}}_x = \int x(t) \, \psi^*_{j, \, k}(t) \, dt</script> <br><br>
        Equation 3.24
      </div>

      <br><br>

      or

      <br><br>

      <!--img src="res/wavelet/part3/equation3_25.png" class="img-responsive" style="display:b5ock; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">x(t) = c_\psi \sum\limits_{j} \sum\limits_{k} \Psi^{\psi_{\, j,k}}_x \, \psi_{\, j,k} (t)</span><script type="math/tex">x(t) = c_\psi \sum\limits_{j} \sum\limits_{k} \Psi^{\psi_{\, j,k}}_x \, \psi_{\, j,k} (t)</script> <br><br>
        Equation 3.25
      </div>

      <br><br>

      A wavelet series requires that <span class="MathJax_Preview">\boldsymbol{ {\psi_{(j, \, k)}} }</span><script type="math/tex">\boldsymbol{ {\psi_{(j, \, k)}} }</script> are either orthonormal, biorthogonal, or frame. If <span class="MathJax_Preview">\boldsymbol{ {\psi_{(j,k)}} }</span><script type="math/tex">\boldsymbol{ {\psi_{(j,k)}} }</script> are not orthonormal, Equation 3.24 becomes

      <br><br>

      <!--img src="res/wavelet/part3/equation3_26.png" class="img-responsive" style="display:b5ock; margin:auto;"-->
      <div class="text-center">
        <span class="MathJax_Preview">\Psi^{\psi_{\, j,k}}_x = \int x(t) \, \hat{\psi^*_{(j, \, k)}(t)} \, dt</span><script type="math/tex">\Psi^{\psi_{\, j,k}}_x = \int x(t) \, \hat{\psi^*_{(j, \, k)}(t)} \, dt</script> <br><br>
        Equation 3.26
      </div>

      <br><br>

      where <span class="MathJax_Preview">\boldsymbol{\hat{\psi_{j, \, k}^*(t)}}</span><script type="math/tex">\boldsymbol{\hat{\psi_{j, \, k}^*(t)}}</script>, is either the <strong>dual biorthogonal basis</strong> or <strong>dual frame</strong> (Note that * denotes the conjugate).

      <br><br>

      If <span class="MathJax_Preview">\boldsymbol{ \{ \psi_{(j, \, k)} \} }</span><script type="math/tex">\boldsymbol{ \{ \psi_{(j, \, k)} \} }</script>
 are orthonormal or biorthogonal, the transform will be non-redundant, 
where as if they form a frame, the transform will be redundant. On the 
other hand, it is much easier to find frames than it is to find 
orthonormal or biorthogonal bases.

      <br><br>

      The following analogy may clear this concept. Consider the whole 
process as looking at a particular object. The human eyes first 
determine the coarse view which depends on the distance of the eyes to 
the object. This corresponds to adjusting the scale parameter <span class="MathJax_Preview">\boldsymbol{s_0^{-j}}</span><script type="math/tex">\boldsymbol{s_0^{-j}}</script>. When looking at a very close object, with great detail, <strong>j</strong>
 is negative and large (low scale, high frequency, analyses the detail 
in the signal). Moving the head (or eyes) very slowly and with very 
small increments (of angle, of distance, depending on the object that is
 being viewed), corresponds to small values of <span class="MathJax_Preview">\boldsymbol{\tau = k \cdot s_0^{\, j} \cdot \tau_0}</span><script type="math/tex">\boldsymbol{\tau = k \cdot s_0^{\, j} \cdot \tau_0}</script>. Note that when <strong>j</strong> is negative and large, it corresponds to small changes in time, <span class="MathJax_Preview">\boldsymbol{\tau}</span><script type="math/tex">\boldsymbol{\tau}</script>, (high sampling rate) and large changes in <span class="MathJax_Preview">\boldsymbol{s_0^{\, j}}</span><script type="math/tex">\boldsymbol{s_0^{\, j}}</script> (low scale, high frequencies, where the sampling rate is high). The scale parameter can be thought of as magnification too.

      <br><br>

      How low can the sampling rate be and still allow reconstruction of
 the signal? This is the main question to be answered to optimize the 
procedure. The most convenient value (in terms of programming) is found 
to be "2" for <span class="MathJax_Preview">s_0</span><script type="math/tex">s_0</script> and "1" for <span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script>.
 Obviously, when the sampling rate is forced to be as low as possible, 
the number of available orthonormal wavelets is also reduced.

      <br><br>

      The continuous wavelet transform examples that were given in this 
chapter were actually the wavelet series of the given signals. The 
parameters were chosen depending on the signal. Since the reconstruction
 was not needed, the sampling rates were sometimes far below the 
critical value where <span class="MathJax_Preview">s_0</span><script type="math/tex">s_0</script> varied from 2 to 10, and <span class="MathJax_Preview">\tau_0</span><script type="math/tex">\tau_0</script> varied from 2 to 8, for different examples.

      <br><br>

      This concludes Part III of this tutorial. I hope you now have a 
basic understanding of what the wavelet transform is all about. There is
 one thing left to be discussed however. Even though the discretized 
wavelet transform can be computed on a computer, this computation may 
take anywhere from a couple seconds to couple hours depending on your 
signal size and the resolution you want. An amazingly fast algorithm is 
actually available to compute the wavelet transform of a signal. The 
discrete wavelet transform (DWT) is introduced in the final chapter of 
this tutorial, in Part IV.

      <br><br>

      Let's meet at the grand finale, shall we?

      <br>
      <hr>

      All Rights Reserved. This tutorial is intended for educational 
purposes only. Unauthorized copying, duplicating and publishing is 
strictly prohibited.

      <br><br>

      Robi Polikar
      <br>
      Rowan University
      <br>
      Phone: (856) 256 5372
      <br>
      <a href="mailto:polikar@rowan.edu">polikar@rowan.edu</a>



    </div> <!-- col-sm-8 page-body -->

    <div class="col-sm-2"></div>

  

  <style>

    /* Put any CSS here */

  </style>

  <script>
  // loads the header
  $(document).ready(function(){
    $("#header").load("header.html");
  });

  // Put any additional JS here

  </script>


</body></html>
